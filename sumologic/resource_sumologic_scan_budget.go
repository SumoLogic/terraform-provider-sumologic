// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//	This file is automatically generated by Sumo Logic and manual
//	changes will be clobbered when the file is regenerated. Do not submit
//	changes to this file.
//
// ----------------------------------------------------------------------------
package sumologic

import (
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
)

func resourceSumologicScanBudget() *schema.Resource {
	return &schema.Resource{
		Create: resourceSumologicScanBudgetCreate,
		Read:   resourceSumologicScanBudgetRead,
		Update: resourceSumologicScanBudgetUpdate,
		Delete: resourceSumologicScanBudgetDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},

		Schema: map[string]*schema.Schema{

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: false,
			},

			"capacity": {
				Type:     schema.TypeInt,
				Required: true,
				ForceNew: false,
			},

			"unit": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: false,
			},

			"budget_type": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: false,
			},

			"window": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: false,
			},

			"group_by": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: false,
			},

			"applicable_on": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: false,
			},

			"scope": {
				Type:     schema.TypeList,
				Required: true,
				ForceNew: false,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"included_users": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"excluded_users": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"included_roles": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"excluded_roles": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"action": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: false,
			},

			"status": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: false,
			},
		},
	}
}

func resourceSumologicScanBudgetCreate(d *schema.ResourceData, meta interface{}) error {
	c := meta.(*Client)

	if d.Id() == "" {
		scanBudget := resourceToScanBudget(d)
		id, err := c.CreateScanBudget(scanBudget)
		if err != nil {
			return err
		}

		d.SetId(id)
	}

	return resourceSumologicScanBudgetRead(d, meta)
}

func resourceSumologicScanBudgetRead(d *schema.ResourceData, meta interface{}) error {
	c := meta.(*Client)

	id := d.Id()
	scanBudget, err := c.GetScanBudget(id)
	if err != nil {
		return err
	}

	if scanBudget == nil {
		log.Printf("[WARN] ScanBudget not found, removing from state: %v - %v", id, err)
		d.SetId("")
		return nil
	}

	d.Set("name", scanBudget.Name)
	d.Set("capacity", scanBudget.Capacity)
	d.Set("unit", scanBudget.Unit)
	d.Set("budget_type", scanBudget.BudgetType)
	d.Set("window", scanBudget.Window)
	d.Set("applicable_on", scanBudget.ApplicableOn)
	d.Set("group_by", scanBudget.GroupBy)
	d.Set("action", scanBudget.Action)
	d.Set("scope", scanBudgetScopeToResource(scanBudget.Scope))
	d.Set("status", scanBudget.Status)

	return nil
}

func resourceSumologicScanBudgetDelete(d *schema.ResourceData, meta interface{}) error {
	c := meta.(*Client)

	return c.DeleteScanBudget(d.Id())
}

func resourceSumologicScanBudgetUpdate(d *schema.ResourceData, meta interface{}) error {
	c := meta.(*Client)

	scanBudget := resourceToScanBudget(d)
	err := c.UpdateScanBudget(scanBudget)
	if err != nil {
		return err
	}

	return resourceSumologicScanBudgetRead(d, meta)
}

func resourceToScanBudget(d *schema.ResourceData) ScanBudget {
	return ScanBudget{
		ID:           d.Id(),
		Name:         d.Get("name").(string),
		Capacity:     d.Get("capacity").(int),
		Unit:         d.Get("unit").(string),
		BudgetType:   d.Get("budget_type").(string),
		Window:       d.Get("window").(string),
		ApplicableOn: d.Get("applicable_on").(string),
		GroupBy:      d.Get("group_by").(string),
		Action:       d.Get("action").(string),
		Scope:        resourceToScanBudgetScope(d.Get("scope")),
		Status:       d.Get("status").(string),
	}
}

func resourceToScanBudgetScope(data interface{}) ScanBudgetScope {
	scopeMap, ok := data.([]interface{})[0].(map[string]interface{})
	if !ok {
		return ScanBudgetScope{}
	}

	scanBudgetScope := ScanBudgetScope{
		IncludedUsers: convertToStringSlice(scopeMap["included_users"]),
		ExcludedUsers: convertToStringSlice(scopeMap["excluded_users"]),
		IncludedRoles: convertToStringSlice(scopeMap["included_roles"]),
		ExcludedRoles: convertToStringSlice(scopeMap["excluded_roles"]),
	}

	return scanBudgetScope
}

func scanBudgetScopeToResource(scanBudgetScope ScanBudgetScope) []map[string]interface{} {
	return []map[string]interface{}{
		{
			"included_users": scanBudgetScope.IncludedUsers,
			"excluded_users": scanBudgetScope.ExcludedUsers,
			"included_roles": scanBudgetScope.IncludedRoles,
			"excluded_roles": scanBudgetScope.ExcludedRoles,
		},
	}
}

func convertToStringSlice(data interface{}) []string {
	if data == nil {
		return nil
	}

	interfaceSlice, ok := data.([]interface{})
	if !ok {
		return nil
	}

	stringSlice := make([]string, len(interfaceSlice))
	for i, v := range interfaceSlice {
		str, ok := v.(string)
		if ok {
			stringSlice[i] = str
		}
	}

	return stringSlice
}
