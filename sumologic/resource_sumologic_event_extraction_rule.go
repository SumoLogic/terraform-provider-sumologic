package sumologic

// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//	This file is automatically generated by Sumo Logic and manual
//	changes will be clobbered when the file is regenerated. Do not submit
//	changes to this file.
//
// ----------------------------------------------------------------------------
package sumologic

import (
"fmt"
"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
"github.com/hashicorp/terraform-plugin-sdk/helper/validation"
"log"
"os"
"strconv"
"time"
)

func resourceSumologicEventExtractionRule() *schema.Resource {
	baseCorrelationExpressionSchema := map[string]*schema.Schema{
		"correlation_expression_type": {
			Type:     schema.TypeString,
			Required: true,
			ValidateFunc: validation.StringInSlice([]string{"StringMatch", "And", "Or"}, false),
		},
		// Add other common fields for correlation expressions here
	}

	// Define the schema for StringMatch correlation expressions
	stringMatchCorrelationExpressionSchema := map[string]*schema.Schema{
		// Inherit fields from the base schema
		"correlation_expression_type": baseCorrelationExpressionSchema["correlation_expression_type"],
		// Add specific fields for StringMatch correlation expressions
		"query_field_name": {
			Type:     schema.TypeString,
			Required: true,
		},
		"event_field_name": {
			Type:     schema.TypeString,
			Required: true,
		},
		"string_matching_algorithm": {
			Type:     schema.TypeString,
			Required: true,
		},
	}

	// Define the schema for And and Or correlation expressions
	andOrCorrelationExpressionSchema := map[string]*schema.Schema{
		// Inherit fields from the base schema
		"correlation_expression_type": baseCorrelationExpressionSchema["correlation_expression_type"],
		// Add specific fields for And and Or correlation expressions
		"correlation_expressions": {
			Type:     schema.TypeList,
			Optional: true,
			Elem: &schema.Resource{
				Schema: baseCorrelationExpressionSchema, // Nested correlation expressions can also inherit from the base schema
			},
		},
	}

	return &schema.Resource{
		Create: resourceSumologicEventExtractionRuleCreate,
		Read:   resourceSumologicEventExtractionRuleRead,
		Update: resourceSumologicEventExtractionRuleUpdate,
		Delete: resourceSumologicEventExtractionRuleDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},

		Schema: map[string]*schema.Schema{

			"name": {
				Type:     schema.TypeString,
				Required: true,
			},

			"description": {
				Type:         schema.TypeString,
				Optional:    true,
				ValidateFunc: validation.StringLenBetween(0, 1000),
				Required:     true,
			},

			"query": {
				Type:     schema.TypeString,
				Required: true,
			},

			"correlation_expression": {
				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: baseCorrelationExpressionSchema,
				},
			},
			"string_match_correlation_expression": {
				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: stringMatchCorrelationExpressionSchema,
				},
			},
			"and_or_correlation_expression": {
				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: andOrCorrelationExpressionSchema,
				},
			},
		},
	}
}


func resourceSumologicEventExtractionRuleCreate(d *schema.ResourceData, meta interface{}) error {
	c := meta.(*Client)

	if d.Id() == "" {
		lookupTable := resourceToLookupTable(d)
		id, err := c.CreateLookupTable(lookupTable)
		if err != nil {
			return err
		}

		d.SetId(id)
	}

	log.Printf("created lookup: %+v\n", d)
	log.Printf("lookup id: %v\n", d.Id())
	return resourceSumologicLookupTableRead(d, meta)
}

func resourceSumologicLookupTableRead(d *schema.ResourceData, meta interface{}) error {
	c := meta.(*Client)

	id := d.Id()
	lookupTable, err := c.GetLookupTable(id)
	log.Printf("##DEBUG## read lookup: %+v\n", lookupTable)
	if err != nil {
		return err
	}

	if lookupTable == nil {
		log.Printf("[WARN] LookupTable not found, removing from state: %v - %v", id, err)
		d.SetId("")
		return nil
	}

	d.Set("name", lookupTable.Name)
	if err := d.Set("fields", fieldsToList(lookupTable.Fields)); err != nil {
		return fmt.Errorf("error setting fields for resource %s: %s", d.Id(), err)
	}
	d.Set("ttl", lookupTable.Ttl)
	d.Set("primary_keys", lookupTable.PrimaryKeys)
	d.Set("parent_folder_id", lookupTable.ParentFolderId)
	d.Set("size_limit_action", lookupTable.SizeLimitAction)
	d.Set("description", lookupTable.Description)
	//d.Set("csv_file_path", lookupTable.CsvFilePath)

	return nil
}

func resourceSumologicLookupTableDelete(d *schema.ResourceData, meta interface{}) error {
	c := meta.(*Client)

	log.Printf("##DEBUG## resourceSumologicLookupTableDelete: %s", d.Id())
	return c.DeleteLookupTable(d.Id())
}

func resourceSumologicLookupTableUpdate(d *schema.ResourceData, meta interface{}) error {
	c := meta.(*Client)

	lookupTable := resourceToLookupTable(d)
	err := c.UpdateLookupTable(lookupTable)
	if err != nil {
		return err
	}

	return resourceSumologicLookupTableRead(d, meta)
}

func resourceToLookupTable(d *schema.ResourceData) LookupTable {

	fieldsData := d.Get("fields").([]interface{})
	var fields []LookupTableField
	for _, data := range fieldsData {
		fields = append(fields, resourceToLookupTableField([]interface{}{data}))
	}

	primaryKeysData := d.Get("primary_keys").([]interface{})
	var primaryKeys []string
	for _, data := range primaryKeysData {
		primaryKeys = append(primaryKeys, data.(string))
	}

	csv_file_path := d.Get("csv_file_path").(string)
	if csv_file_path != "" {
		lastUpdatedTime, _ := getLastModifiedTimeInMillis(csv_file_path)
		log.Printf("lastUpdatedTime: %d", lastUpdatedTime)
		csv_file_path = csv_file_path + "_" + strconv.FormatInt(lastUpdatedTime, 10)
		d.Set("csv_file_path", csv_file_path)
	}

	return LookupTable{
		Name:            d.Get("name").(string),
		ID:              d.Id(),
		Fields:          fields,
		Description:     d.Get("description").(string),
		Ttl:             d.Get("ttl").(int),
		SizeLimitAction: d.Get("size_limit_action").(string),
		PrimaryKeys:     primaryKeys,
		ParentFolderId:  d.Get("parent_folder_id").(string),
		CsvFilePath:     csv_file_path,
	}
}

func getLastModifiedTimeInMillis(filePath string) (int64, error) {
	// Get file information
	fileInfo, err := os.Stat(filePath)
	if err != nil {
		return 0, err
	}

	// Get the last modified timestamp
	lastModifiedTime := fileInfo.ModTime()

	// Convert last modified time to milliseconds since Unix epoch
	lastModifiedTimeMillis := lastModifiedTime.UnixNano() / int64(time.Millisecond)

	return lastModifiedTimeMillis, nil
}

func resourceToLookupTableField(data interface{}) LookupTableField {

	lookupTableFieldSlice := data.([]interface{})
	lookupTableField := LookupTableField{}
	if len(lookupTableFieldSlice) > 0 {
		lookupTableFieldObj := lookupTableFieldSlice[0].(map[string]interface{})
		lookupTableField.FieldName = lookupTableFieldObj["field_name"].(string)
		lookupTableField.FieldType = lookupTableFieldObj["field_type"].(string)
	}

	return lookupTableField
}

func fieldsToList(lookupTableField []LookupTableField) []map[string]interface{} {
	var s []map[string]interface{}

	for _, t := range lookupTableField {
		mapping := map[string]interface{}{
			"field_name": t.FieldName,
			"field_type": t.FieldType,
		}
		s = append(s, mapping)
	}

	return s
}

