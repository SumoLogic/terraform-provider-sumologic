// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//	This file is automatically generated by Sumo Logic and manual
//	changes will be clobbered when the file is regenerated. Do not submit
//	changes to this file.
//
// ----------------------------------------------------------------------------
package sumologic

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
)

func (s *Client) CreateLookupTable(lookupTable LookupTable) (string, error) {
	urlWithoutParams := "v1/lookupTables"
	csvFilePath := lookupTable.CsvFilePath
	lookupTable.CsvFilePath = ""
	data, err := s.Post(urlWithoutParams, lookupTable)
	if err != nil {
		return "", err
	}

	var createdLookupTable LookupTable

	err = json.Unmarshal(data, &createdLookupTable)
	if err != nil {
		return "", err
	}

	log.Printf("##DEBUG## created lookuptable: %+v\n\n", createdLookupTable)

	err = s.populateLookupTable(lookupTable.ID, csvFilePath)
	if err != nil {
		return "", err
	}

	log.Printf("##DEBUG## populated lookuptable: %+v\n\n", createdLookupTable)

	return createdLookupTable.ID, nil

}

func (s *Client) GetLookupTable(id string) (*LookupTable, error) {
	urlWithoutParams := "v1/lookupTables/%s"
	paramString := ""
	sprintfArgs := []interface{}{}
	sprintfArgs = append(sprintfArgs, id)

	urlWithParams := fmt.Sprintf(urlWithoutParams+paramString, sprintfArgs...)

	data, _, err := s.Get(urlWithParams)
	if err != nil {
		return nil, err
	}
	if data == nil {
		return nil, nil
	}

	var lookupTable LookupTable

	err = json.Unmarshal(data, &lookupTable)
	if err != nil {
		return nil, err
	}

	return &lookupTable, nil

}

func (s *Client) DeleteLookupTable(id string) error {
	urlWithoutParams := "v1/lookupTables/%s"
	paramString := ""
	sprintfArgs := []interface{}{}
	sprintfArgs = append(sprintfArgs, id)

	urlWithParams := fmt.Sprintf(urlWithoutParams+paramString, sprintfArgs...)

	log.Printf("deleting lookuptable: %s", id)
	_, err := s.Delete(urlWithParams)

	return err
}

func (s *Client) UpdateLookupTable(lookupTable LookupTable) error {
	urlWithoutParams := "v1/lookupTables/%s"
	paramString := ""
	sprintfArgs := []interface{}{}
	sprintfArgs = append(sprintfArgs, lookupTable.ID)

	urlWithParams := fmt.Sprintf(urlWithoutParams+paramString, sprintfArgs...)

	csvFilePath := lookupTable.CsvFilePath
	lookupId := lookupTable.ID
	lookupTable.ID = ""
	lookupTable.CsvFilePath = ""
	_, err := s.Put(urlWithParams, lookupTable)
	if err != nil {
		return err
	}

	err = s.populateLookupTable(lookupId, csvFilePath)
	return err
}

func (s *Client) populateLookupTable(lookupTableId string, csvFilePath string) error {
	if csvFilePath != "" && lookupTableId != "" {
		log.Printf("populating lookuptable with file contents: %s", csvFilePath)
		file, err := os.Open(csvFilePath)
		if err != nil {
			fmt.Println("Error:", err)
			return err
		}
		defer file.Close()

		url := fmt.Sprintf("v1/lookupTables/%s/upload", lookupTableId)
		_, err = s.PostMultipart(url, "file", "lookup_contents.csv", file)

		return err
	}
	log.Printf("populated lookuptable with file contents: %s", csvFilePath)
	return nil
}

type LookupTable struct {
	Fields          []LookupTableField `json:"fields,omitempty"`
	SizeLimitAction string             `json:"sizeLimitAction"`
	Name            string             `json:"name"`
	ID              string             `json:"id,omitempty"`
	ParentFolderId  string             `json:"parentFolderId"`
	PrimaryKeys     []string           `json:"primaryKeys,omitempty"`
	Description     string             `json:"description"`
	Ttl             int                `json:"ttl"`
	CsvFilePath     string             `json:"csvFilePath,omitempty"`
}

type LookupTableField struct {
	FieldName string `json:"fieldName"`
	FieldType string `json:"fieldType"`
}
